# 알고리즘이란 무엇인가?
# 알고리즘은 어떤 문제를 해결하기 위한 절차나 방법을 말한다

# 좋은 알고리즘의 5가지 조건:
# 1. 입력 (input)
# 0개 이상의 외부 데이터가 있어야한다

# 2. 출력 (output)
# 1개 이상의 결과가 있어야한다

# 3. 명확성 (definiteness)
# 값이 명확해야한다

# 4. 유한성 (finiteness)
# 언젠가는 반드시 끝나야한다

# 5. 효율성 (effectiveness)
# 실행 가능하고, 효율적이여야한다.

#

# 1. 시간 복잡도

# O(N) (선형 시간)
# 처음부터 끝까지 정직하게 늘어난다

# O(N^2) (이차시간)
# 책 하나를 꺼내서 다른 모든책과 내용을 비교한다. (책이 조금만 늘어나도, 제곱으로 늘어난다)


# big-o 표기법 
# 데이터 입력 크기에 따라 실행시간이 얼마나 늘어나는지 나타내는 지표

# 절대규칙
# python은 일반적으로 1초에  약 1억번 계산이 가능합니다.

# Discord 이미지 참고!

# sys는 요류없이 빨리하는 느낌 (더좋음)
# input은 오류없이 천천히하는 느낌 (덜좋음)

import sys

input=sys.stdin.readline

# 재귀함수
# 함수안에서 자기자신을 다시 호출하는 함수

# 구성요소
# 1. base case
# 재귀를 멈추는 조건

# 2. 재귀호출
# 문제를 더 작은 단위로 쪼개어 자신을 부르는 부분

def factorial(n):
    if n==1: #base case
        return 1 
    return n*factorial(n-1) #재귀호출


# 자료 구조
# 1. stack
# 마지막인게 먼저 나온다. (과자)
# 용도: undo, 괄호 짝맞추기, dfs

# 2. queue 
# 먼저오면 먼저 간다. 
# bfs, 순서대로 처리해야하는 작업

# 3. deque
# 만능 리스트
# 어디서든지 데이터를 삭제, 추가 가능.
# -> O(1)

from collections import deque
DQ= deque([1, 2, 3, 4, 5])

# dfs
# dfs = 깊이
# 외쪽으로 끝까지 가서 아니면 다시 되돌아 온다
# 재귀함수나 stack으 쓴다
# 모든 경우의 수를 탐색하든가, 경로의 특징으로 저장해서 쓴다

# bfs 
# bfs = 너비
# 시작 지점에서부터 가까운데부터 훌트고 간다
# queue나 deque를 사용한다.
# 최단거리 구할떄 bfs가 쓰인다.
